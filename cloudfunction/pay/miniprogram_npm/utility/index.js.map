{"version":3,"sources":["utility.js","function.js","polyfill.js","optimize.js","crypto.js","number.js","string.js","array.js","json.js","date.js","object.js","web.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA;AIXA,AHSA,AENA,ADGA,AFMA;AIXA,AHSA,AENA,ADGA,AFMA;AIXA,AHSA,AENA,AHSA;AIXA,AHSA,AIZA,AFMA,AHSA;AIXA,AHSA,AIZA,AFMA,AHSA;AIXA,AHSA,AIZA,AFMA;ACFA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;AFOA,AHSA,AIZA,AFMA,AGTA;ACFA,AHSA,AHSA,AIZA,AFMA,AGTA;ACFA,AHSA,AHSA,AIZA,AFMA,AGTA;ACFA,AHSA,AHSA,AIZA,AFMA,AGTA;ACFA,AHSA,AHSA,AOrBA,AHSA,AFMA,AGTA;ACFA,AHSA,AHSA,AOrBA,AHSA,AFMA,AGTA;ACFA,AHSA,AHSA,AOrBA,AHSA,AFMA,AGTA;ACFA,AHSA,AKfA,ARwBA,AOrBA,AHSA,AFMA,AGTA;ACFA,AHSA,AKfA,ARwBA,AOrBA,AHSA,AFMA,AGTA;ACFA,AHSA,AKfA,ARwBA,AOrBA,AHSA,AFMA,AGTA;ACFA,AHSA,AKfA,ARwBA,AOrBA,AHSA,AKfA,APqBA,AGTA;ACFA,AHSA,AKfA,ARwBA,AOrBA,AHSA,AKfA,APqBA,AGTA;ACFA,AHSA,AKfA,ARwBA,AOrBA,AHSA,AKfA,APqBA,AGTA;ACFA,AHSA,AKfA,ARwBA,AOrBA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ARwBA,AOrBA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ARwBA,AOrBA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;AJaA,AHSA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;APsBA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;APsBA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;APsBA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;APsBA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;APsBA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;APsBA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;APsBA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;APsBA,AKfA,ADGA,AHSA,AKfA,APqBA,AGTA,AKfA;APsBA,AKfA,ADGA,AENA,APqBA,AGTA,AKfA;APsBA,AKfA,ADGA,AENA,APqBA,AGTA,AKfA;APsBA,AKfA,ADGA,AENA,APqBA,AGTA,AKfA;APsBA,AKfA,ADGA,AENA,AJYA,AKfA;APsBA,AKfA,ADGA,AENA,AJYA,AKfA;APsBA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ADGA,AENA,AJYA;AFOA,AKfA,ACHA,AJYA;AFOA,AKfA,ACHA,AJYA;AFOA,AKfA,ACHA,AJYA;AFOA,AKfA,ACHA,AJYA;AFOA,AKfA,ACHA,AJYA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar copy = require('copy-to');\n\ncopy(require('./function'))\n.and(require('./polyfill'))\n.and(require('./optimize'))\n.and(require('./crypto'))\n.and(require('./number'))\n.and(require('./string'))\n.and(require('./array'))\n.and(require('./json'))\n.and(require('./date'))\n.and(require('./object'))\n.and(require('./web'))\n.to(module.exports);\n","\n\nvar assert = require('assert');\n\n/**\n * A empty function.\n *\n * @return {Function}\n * @public\n */\nexports.noop = function noop() {};\n\n/**\n * Get a function parameter's names.\n *\n * @param {Function} func\n * @param {Boolean} [useCache], default is true\n * @return {Array} names\n */\nexports.getParamNames = function getParamNames(func, cache) {\n  var type = typeof func;\n  assert(type === 'function', 'The \"func\" must be a function. Received type \"' + type + '\"');\n\n  cache = cache !== false;\n  if (cache && func.__cache_names) {\n    return func.__cache_names;\n  }\n  var str = func.toString();\n  var names = str.slice(str.indexOf('(') + 1, str.indexOf(')')).match(/([^\\s,]+)/g) || [];\n  func.__cache_names = names;\n  return names;\n};\n","\n\nexports.setImmediate = typeof setImmediate === 'function'\n  ? setImmediate\n  : function(fn){\n    process.nextTick(fn.bind.apply(fn, arguments));\n  };\n","\n\n/**\n * optimize try catch\n * @param {Function} fn\n * @return {Object}\n *   - {Error} error\n *   - {Mix} value\n */\nexports.try = function (fn) {\n  var res = {\n    error: undefined,\n    value: undefined\n  };\n\n  try {\n    res.value = fn();\n  } catch (err) {\n    res.error = err instanceof Error\n      ? err\n      : new Error(err);\n  }\n\n  return res;\n};\n\n\n/**\n * @description Deal with typescript\n */\nexports.UNSTABLE_METHOD = {\n  try: exports.try,\n};\n\n\n/**\n * avoid if (a && a.b && a.b.c)\n * @param {Object} obj\n * @param {...String} keys\n * @return {Object}\n */\nexports.dig = function (obj) {\n  if (!obj) {\n    return;\n  }\n  if (arguments.length <= 1) {\n    return obj;\n  }\n\n  var value = obj[arguments[1]];\n  for (var i = 2; i < arguments.length; i++) {\n    if (!value) {\n      break;\n    }\n    value = value[arguments[i]];\n  }\n\n  return value;\n};\n\n/**\n * optimize arguments to array\n * @param {Arguments} args\n * @return {Array}\n */\nexports.argumentsToArray = function (args) {\n  var res = new Array(args.length);\n  for (var i = 0; i < args.length; i++) {\n    res[i] = args[i];\n  }\n  return res;\n};\n","\n\nvar crypto = require('crypto');\n\n/**\n * hash\n *\n * @param {String} method hash method, e.g.: 'md5', 'sha1'\n * @param {String|Buffer} s\n * @param {String} [format] output string format, could be 'hex' or 'base64'. default is 'hex'.\n * @return {String} md5 hash string\n * @public\n */\nexports.hash = function hash(method, s, format) {\n  var sum = crypto.createHash(method);\n  var isBuffer = Buffer.isBuffer(s);\n  if (!isBuffer && typeof s === 'object') {\n    s = JSON.stringify(sortObject(s));\n  }\n  sum.update(s, isBuffer ? 'binary' : 'utf8');\n  return sum.digest(format || 'hex');\n};\n\n/**\n * md5 hash\n *\n * @param {String|Buffer} s\n * @param {String} [format] output string format, could be 'hex' or 'base64'. default is 'hex'.\n * @return {String} md5 hash string\n * @public\n */\nexports.md5 = function md5(s, format) {\n  return exports.hash('md5', s, format);\n};\n\n/**\n * sha1 hash\n *\n * @param {String|Buffer} s\n * @param {String} [format] output string format, could be 'hex' or 'base64'. default is 'hex'.\n * @return {String} sha1 hash string\n * @public\n */\nexports.sha1 = function sha1(s, format) {\n  return exports.hash('sha1', s, format);\n};\n\n/**\n * sha256 hash\n *\n * @param {String|Buffer} s\n * @param {String} [format] output string format, could be 'hex' or 'base64'. default is 'hex'.\n * @return {String} sha256 hash string\n * @public\n */\nexports.sha256 = function sha256(s, format) {\n  return exports.hash('sha256', s, format);\n};\n\n/**\n * HMAC algorithm.\n *\n * Equal bash:\n *\n * ```bash\n * $ echo -n \"$data\" | openssl dgst -binary -$algorithm -hmac \"$key\" | openssl $encoding\n * ```\n *\n * @param {String} algorithm, dependent on the available algorithms supported by the version of OpenSSL on the platform.\n *   Examples are 'sha1', 'md5', 'sha256', 'sha512', etc.\n *   On recent releases, `openssl list-message-digest-algorithms` will display the available digest algorithms.\n * @param {String} key, the hmac key to be used.\n * @param {String|Buffer} data, content string.\n * @param {String} [encoding='base64']\n * @return {String} digest string.\n */\nexports.hmac = function hmac(algorithm, key, data, encoding) {\n  encoding = encoding || 'base64';\n  var hmac = crypto.createHmac(algorithm, key);\n  hmac.update(data, Buffer.isBuffer(data) ? 'binary' : 'utf8');\n  return hmac.digest(encoding);\n};\n\n/**\n * Base64 encode string.\n *\n * @param {String|Buffer} s\n * @param {Boolean} [urlsafe=false] Encode string s using a URL-safe alphabet,\n *   which substitutes - instead of + and _ instead of / in the standard Base64 alphabet.\n * @return {String} base64 encode format string.\n */\nexports.base64encode = function base64encode(s, urlsafe) {\n  if (!Buffer.isBuffer(s)) {\n    s = typeof Buffer.from === 'function' ? Buffer.from(s) : new Buffer(s);\n  }\n  var encode = s.toString('base64');\n  if (urlsafe) {\n    encode = encode.replace(/\\+/g, '-').replace(/\\//g, '_');\n  }\n  return encode;\n};\n\n/**\n * Base64 string decode.\n *\n * @param {String} encode, base64 encoding string.\n * @param {Boolean} [urlsafe=false] Decode string s using a URL-safe alphabet,\n *   which substitutes - instead of + and _ instead of / in the standard Base64 alphabet.\n * @param {encoding} [encoding=utf8] if encoding = buffer, will return Buffer instance\n * @return {String|Buffer} plain text.\n */\nexports.base64decode = function base64decode(encodeStr, urlsafe, encoding) {\n  if (urlsafe) {\n    encodeStr = encodeStr.replace(/\\-/g, '+').replace(/_/g, '/');\n  }\n  var buf = typeof Buffer.from === 'function' ? Buffer.from(encodeStr, 'base64') : new Buffer(encodeStr, 'base64');\n  if (encoding === 'buffer') {\n    return buf;\n  }\n  return buf.toString(encoding || 'utf8');\n};\n\nfunction sortObject(o) {\n  if (!o || Array.isArray(o) || typeof o !== 'object') {\n    return o;\n  }\n  var keys = Object.keys(o);\n  keys.sort();\n  var values = [];\n  for (var i = 0; i < keys.length; i++) {\n    var k = keys[i];\n    values.push([k, sortObject(o[k])]);\n  }\n  return values;\n}\n","\n\n// http://www.2ality.com/2013/10/safe-integers.html\n// http://es6.ruanyifeng.com/#docs/number\nexports.MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;\nexports.MIN_SAFE_INTEGER = -exports.MAX_SAFE_INTEGER;\nvar MAX_SAFE_INTEGER_STR = exports.MAX_SAFE_INTEGER_STR = String(exports.MAX_SAFE_INTEGER);\nvar MAX_SAFE_INTEGER_STR_LENGTH = MAX_SAFE_INTEGER_STR.length;\n\n/**\n * Detect a number string can safe convert to Javascript Number.\n *\n * @param {String} s number format string, like `\"123\"`, `\"-1000123123123123123123\"`\n * @return {Boolean}\n */\nexports.isSafeNumberString = function isSafeNumberString(s) {\n  if (s[0] === '-') {\n    s = s.substring(1);\n  }\n  if (s.length < MAX_SAFE_INTEGER_STR_LENGTH ||\n    (s.length === MAX_SAFE_INTEGER_STR_LENGTH && s <= MAX_SAFE_INTEGER_STR)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Convert string to Number if string in safe Number scope.\n *\n * @param {String} s number format string.\n * @return {Number|String} success will return Number, otherise return the original string.\n */\nexports.toSafeNumber = function toSafeNumber(s) {\n  if (typeof s === 'number') {\n    return s;\n  }\n\n  return exports.isSafeNumberString(s) ? Number(s) : s;\n};\n\n/**\n * Produces a random integer between the inclusive `lower` and `upper` bounds.\n *\n * @param {Number} lower The lower bound.\n * @param {Number} upper The upper bound.\n * @return {Number} Returns the random number.\n */\nexports.random = function random(lower, upper) {\n  if (lower === undefined && upper === undefined) {\n    return 0;\n  }\n  if (upper === undefined) {\n    upper = lower;\n    lower = 0;\n  }\n  var temp;\n  if (lower > upper) {\n    temp = lower;\n    lower = upper;\n    upper = temp;\n  }\n  return Math.floor(lower + Math.random() * (upper - lower));\n};\n","\n\nexports.randomString = function randomString(length, charSet) {\n  var result = [];\n  length = length || 16;\n  charSet = charSet || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\n  while (length--) {\n    result.push(charSet[Math.floor(Math.random() * charSet.length)]);\n  }\n  return result.join('');\n};\n\n/**\n * split string to array\n * @param  {String} str\n * @param  {String} [sep] default is ','\n * @return {Array}\n */\nexports.split = function split(str, sep) {\n  str = str || '';\n  sep = sep || ',';\n  var items = str.split(sep);\n  var needs = [];\n  for (var i = 0; i < items.length; i++) {\n    var s = items[i].trim();\n    if (s.length > 0) {\n      needs.push(s);\n    }\n  }\n  return needs;\n};\n// always optimized\nexports.splitAlwaysOptimized = function splitAlwaysOptimized() {\n  var str = '';\n  var sep = ',';\n  if (arguments.length === 1) {\n    str = arguments[0] || '';\n  } else if (arguments.length === 2) {\n    str = arguments[0] || '';\n    sep = arguments[1] || ',';\n  }\n  var items = str.split(sep);\n  var needs = [];\n  for (var i = 0; i < items.length; i++) {\n    var s = items[i].trim();\n    if (s.length > 0) {\n      needs.push(s);\n    }\n  }\n  return needs;\n};\n\n/**\n * Replace string\n *\n * @param  {String} str\n * @param  {String|RegExp} substr\n * @param  {String|Function} newSubstr\n * @return {String}\n */\nexports.replace = function replace(str, substr, newSubstr) {\n  var replaceFunction = newSubstr;\n  if (typeof replaceFunction !== 'function') {\n    replaceFunction = function () {\n      return newSubstr;\n    };\n  }\n  return str.replace(substr, replaceFunction);\n};\n\n// original source https://github.com/nodejs/node/blob/v7.5.0/lib/_http_common.js#L300\n/**\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\nvar validHdrChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  // ... 255\n];\n\n/**\n * Replace invalid http header characters with replacement\n *\n * @param  {String} val\n * @param  {String|Function} replacement - can be `function(char)`\n * @return {Object}\n */\nexports.replaceInvalidHttpHeaderChar = function replaceInvalidHttpHeaderChar(val, replacement) {\n  replacement = replacement || ' ';\n  var invalid = false;\n\n  if (!val || typeof val !== 'string') {\n    return {\n      val: val,\n      invalid: invalid,\n    };\n  }\n\n  var replacementType = typeof replacement;\n  var chars;\n  for (var i = 0; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      // delay create chars\n      chars = chars || val.split('');\n      if (replacementType === 'function') {\n        chars[i] = replacement(chars[i]);\n      } else {\n        chars[i] = replacement;\n      }\n    }\n  }\n\n  if (chars) {\n    val = chars.join('');\n    invalid = true;\n  }\n\n  return {\n    val: val,\n    invalid: invalid,\n  };\n};\n\n/**\n * Detect invalid http header characters in a string\n *\n * @param {String} val\n * @return {Boolean}\n */\nexports.includesInvalidHttpHeaderChar = function includesInvalidHttpHeaderChar(val) {\n  if (!val || typeof val !== 'string') {\n    return false;\n  }\n\n  for (var i = 0; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      return true;\n    }\n  }\n\n  return false;\n};\n","\n\n/**\n * Array random slice with items count.\n * @param {Array} arr\n * @param {Number} num, number of sub items.\n * @return {Array}\n */\nexports.randomSlice = function randomSlice(arr, num) {\n  if (!num || num >= arr.length) {\n    return arr.slice();\n  }\n  var index = Math.floor(Math.random() * arr.length);\n  var a = [];\n  for (var i = 0, j = index; i < num; i++) {\n    a.push(arr[j++]);\n    if (j === arr.length) {\n      j = 0;\n    }\n  }\n  return a;\n};\n\n/**\n * Remove one exists element from an array\n * @param {Array} arr\n * @param  {Number} index - remove element index\n * @return {Array} the array instance\n */\nexports.spliceOne = function spliceOne(arr, index) {\n  if (index < 0) {\n    index = arr.length + index;\n    // still negative, not found element\n    if (index < 0) {\n      return arr;\n    }\n  }\n\n  // don't touch\n  if (index >= arr.length) {\n    return arr;\n  }\n\n  for (var i = index, k = i + 1, n = arr.length; k < n; i += 1, k += 1) {\n    arr[i] = arr[k];\n  }\n  arr.pop();\n  return arr;\n};\n","\n\nvar fs = require('mz/fs');\nvar path = require('path');\nvar mkdirp = require('mkdirp');\n\nexports.strictJSONParse = function (str) {\n  var obj = JSON.parse(str);\n  if (!obj || typeof obj !== 'object') {\n    throw new Error('JSON string is not object');\n  }\n  return obj;\n};\n\nexports.readJSONSync = function(filepath) {\n  if (!fs.existsSync(filepath)) {\n    throw new Error(filepath + ' is not found');\n  }\n  return JSON.parse(fs.readFileSync(filepath));\n};\n\nexports.writeJSONSync = function(filepath, str, options) {\n  options = options || {};\n  if (!('space' in options)) {\n    options.space = 2;\n  }\n\n  mkdirp.sync(path.dirname(filepath));\n  if (typeof str === 'object') {\n    str = JSON.stringify(str, options.replacer, options.space) + '\\n';\n  }\n\n  fs.writeFileSync(filepath, str);\n};\n\nexports.readJSON = function(filepath) {\n  return fs.exists(filepath)\n    .then(function(exists) {\n      if (!exists) {\n        throw new Error(filepath + ' is not found');\n      }\n      return fs.readFile(filepath);\n    })\n    .then(function(buf) {\n      return JSON.parse(buf);\n    });\n};\n\nexports.writeJSON = function(filepath, str, options) {\n  options = options || {};\n  if (!('space' in options)) {\n    options.space = 2;\n  }\n\n  if (typeof str === 'object') {\n    str = JSON.stringify(str, options.replacer, options.space) + '\\n';\n  }\n\n  return mkdir(path.dirname(filepath))\n    .then(function() {\n      return fs.writeFile(filepath, str);\n    });\n};\n\nfunction mkdir(dir) {\n  return new Promise(function(resolve, reject) {\n    mkdirp(dir, function(err) {\n      if (err) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n}\n","\n\nvar MONTHS = [\n  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'\n];\n\n// only set once.\nvar TIMEZONE = ' ';\nvar _hourOffset = parseInt(-(new Date().getTimezoneOffset()) / 60, 10);\nif (_hourOffset >= 0) {\n  TIMEZONE += '+';\n} else {\n  TIMEZONE += '-';\n}\n_hourOffset = Math.abs(_hourOffset);\nif (_hourOffset < 10) {\n  _hourOffset = '0' + _hourOffset;\n}\nTIMEZONE += _hourOffset + '00';\n\n/**\n * Access log format date. format: `moment().format('DD/MMM/YYYY:HH:mm:ss ZZ')`\n *\n * @return {String}\n */\nexports.accessLogDate = function (d) {\n  // 16/Apr/2013:16:40:09 +0800\n  d = d || new Date();\n  var date = d.getDate();\n  if (date < 10) {\n    date = '0' + date;\n  }\n  var hours = d.getHours();\n  if (hours < 10) {\n    hours = '0' + hours;\n  }\n  var mintues = d.getMinutes();\n  if (mintues < 10) {\n    mintues = '0' + mintues;\n  }\n  var seconds = d.getSeconds();\n  if (seconds < 10) {\n    seconds = '0' + seconds;\n  }\n  return date + '/' + MONTHS[d.getMonth()] + '/' + d.getFullYear() +\n    ':' + hours + ':' + mintues + ':' + seconds + TIMEZONE;\n};\n\n/**\n * Normal log format date. format: `moment().format('YYYY-MM-DD HH:mm:ss.SSS')`\n *\n * @return {String}\n */\nexports.logDate = exports.YYYYMMDDHHmmssSSS = function (d, msSep) {\n  if (typeof d === 'string') {\n    // logDate(msSep)\n    msSep = d;\n    d = new Date();\n  } else {\n    // logDate(d, msSep)\n    d = d || new Date();\n  }\n  var date = d.getDate();\n  if (date < 10) {\n    date = '0' + date;\n  }\n  var month = d.getMonth() + 1;\n  if (month < 10) {\n    month = '0' + month;\n  }\n  var hours = d.getHours();\n  if (hours < 10) {\n    hours = '0' + hours;\n  }\n  var mintues = d.getMinutes();\n  if (mintues < 10) {\n    mintues = '0' + mintues;\n  }\n  var seconds = d.getSeconds();\n  if (seconds < 10) {\n    seconds = '0' + seconds;\n  }\n  var milliseconds = d.getMilliseconds();\n  if (milliseconds < 10) {\n    milliseconds = '00' + milliseconds;\n  } else if (milliseconds < 100) {\n    milliseconds = '0' + milliseconds;\n  }\n  return d.getFullYear() + '-' + month + '-' + date + ' ' +\n    hours + ':' + mintues + ':' + seconds + (msSep || '.') + milliseconds;\n};\n\n/**\n * `moment().format('YYYY-MM-DD HH:mm:ss')` format date string.\n *\n * @return {String}\n */\nexports.YYYYMMDDHHmmss = function (d, options) {\n  d = d || new Date();\n  if (!(d instanceof Date)) {\n    d = new Date(d);\n  }\n\n  var dateSep = '-';\n  var timeSep = ':';\n  if (options) {\n    if (options.dateSep) {\n      dateSep = options.dateSep;\n    }\n    if (options.timeSep) {\n      timeSep = options.timeSep;\n    }\n  }\n  var date = d.getDate();\n  if (date < 10) {\n    date = '0' + date;\n  }\n  var month = d.getMonth() + 1;\n  if (month < 10) {\n    month = '0' + month;\n  }\n  var hours = d.getHours();\n  if (hours < 10) {\n    hours = '0' + hours;\n  }\n  var mintues = d.getMinutes();\n  if (mintues < 10) {\n    mintues = '0' + mintues;\n  }\n  var seconds = d.getSeconds();\n  if (seconds < 10) {\n    seconds = '0' + seconds;\n  }\n  return d.getFullYear() + dateSep + month + dateSep + date + ' ' +\n    hours + timeSep + mintues + timeSep + seconds;\n};\n\n/**\n * `moment().format('YYYY-MM-DD')` format date string.\n *\n * @return {String}\n */\nexports.YYYYMMDD = function YYYYMMDD(d, sep) {\n  if (typeof d === 'string') {\n    // YYYYMMDD(sep)\n    sep = d;\n    d = new Date();\n  } else {\n    // YYYYMMDD(d, sep)\n    d = d || new Date();\n    if (typeof sep !== 'string') {\n      sep = '-';\n    }\n  }\n  var date = d.getDate();\n  if (date < 10) {\n    date = '0' + date;\n  }\n  var month = d.getMonth() + 1;\n  if (month < 10) {\n    month = '0' + month;\n  }\n  return d.getFullYear() + sep + month + sep + date;\n};\n\n/**\n * return datetime struct.\n *\n * @return {Object} date\n *  - {Number} YYYYMMDD, 20130401\n *  - {Number} H, 0, 1, 9, 12, 23\n */\nexports.datestruct = function (now) {\n  now = now || new Date();\n  return {\n    YYYYMMDD: now.getFullYear() * 10000 + (now.getMonth() + 1) * 100 + now.getDate(),\n    H: now.getHours()\n  };\n};\n\n/**\n * Get Unix's timestamp in seconds.\n * @return {Number}\n */\nexports.timestamp = function timestamp(t) {\n  if (t) {\n    var v = t;\n    if (typeof v === 'string') {\n      v = Number(v);\n    }\n    if (String(t).length === 10) {\n      v *= 1000;\n    }\n    return new Date(v);\n  }\n  return Math.round(Date.now() / 1000);\n};\n","\n\n/**\n * High performance assign before node6\n * @param {Object} target - target object\n * @param {Object | Array} objects - object assign from\n * @return {Object} - return target object\n */\nexports.assign = function(target, objects) {\n  if (!Array.isArray(objects)) {\n    objects = [ objects ];\n  }\n\n  for (var i = 0; i < objects.length; i++) {\n    var obj = objects[i];\n    if (obj) {\n      var keys = Object.keys(obj);\n      for (var j = 0; j < keys.length; j++) {\n        var key = keys[j];\n        target[key] = obj[key];\n      }\n    }\n  }\n  return target;\n};\n\nexports.has = function has(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n};\n\n/**\n * Get all enumerable and ownership of property names\n * @param {Object} obj - detect object\n * @param {Boolean} [ignoreNull] - ignore null, undefined or NaN property\n * @return {Array<String>} property names\n */\nexports.getOwnEnumerables = function getOwnEnumerables(obj, ignoreNull) {\n  if (!obj || typeof obj !== 'object' || Array.isArray(obj)) {\n    return [];\n  }\n  return Object.keys(obj).filter(function(key) {\n    if (ignoreNull) {\n      var value = obj[key];\n      if (value === null || value === undefined || Number.isNaN(value)) {\n        return false;\n      }\n    }\n    return exports.has(obj, key);\n  });\n};\n\n/**\n * generate a real map object(clean object), no constructor, no __proto__\n * @param {Object} [obj] - init object, optional\n * @return {Object}\n */\nexports.map = function map(obj) {\n  var map = new EmptyObject();\n  if (!obj) {\n    return map;\n  }\n\n  for (var key in obj) {\n    map[key] = obj[key];\n  }\n  return map;\n};\n\n// faster way like `Object.create(null)` to get a 'clean' empty object\n// https://github.com/nodejs/node/blob/master/lib/events.js#L5\n// https://cnodejs.org/topic/571e0c445a26c4a841ecbcf1\nfunction EmptyObject() {}\nEmptyObject.prototype = Object.create(null);\n","\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @public\n */\nexports.escape = require('escape-html');\n\n\n/**\n * Unescape the given string from html\n * @param {String} html\n * @param {String} type\n * @return {String}\n * @public\n */\nexports.unescape = require('unescape');\n\n/**\n * Safe encodeURIComponent, won't throw any error.\n * If `encodeURIComponent` error happen, just return the original value.\n *\n * @param {String} text\n * @return {String} URL encode string.\n */\nexports.encodeURIComponent = function encodeURIComponent_(text) {\n  try {\n    return encodeURIComponent(text);\n  } catch (e) {\n    return text;\n  }\n};\n\n/**\n * Safe decodeURIComponent, won't throw any error.\n * If `decodeURIComponent` error happen, just return the original value.\n *\n * @param {String} encodeText\n * @return {String} URL decode original string.\n */\nexports.decodeURIComponent = function decodeURIComponent_(encodeText) {\n  try {\n    return decodeURIComponent(encodeText);\n  } catch (e) {\n    return encodeText;\n  }\n};\n"]}