{"version":3,"sources":["index.js","urllib.js","detect_proxy_agent.js","get_proxy_from_uri.js","../package.json","httpclient.js","httpclient2.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,ACHA,AHSA,ACHA;AGRA,AFMA,ACHA,AHSA,ACHA;AGRA,AFMA,ACHA,AHSA,ACHA;AGRA,AFMA,ACHA,AHSA,ACHA;AGRA,AFMA,ACHA,AENA,ALeA,ACHA;AGRA,AFMA,ACHA,AENA,ALeA,ACHA;AGRA,AFMA,ACHA,AENA,ALeA,ACHA;AGRA,AFMA,ACHA,AENA,ACHA,ANkBA,ACHA;AGRA,AFMA,ACHA,AENA,ACHA,ANkBA,ACHA;AGRA,AFMA,ACHA,AENA,ACHA,ANkBA,ACHA;AGRA,AFMA,ACHA,AENA,ACHA,ANkBA,ACHA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,AFMA,ACHA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AENA,ACHA,ALeA;AGRA,ADGA,AGTA,ALeA;AGRA,ADGA,AGTA,ALeA;AGRA,ADGA,AGTA,ALeA;AGRA,ADGA,AGTA,ALeA;AGRA,ADGA,AGTA,ALeA;AGRA,ADGA,AGTA,ALeA;AGRA,ADGA,AGTA,ALeA;AGRA,ADGA,AGTA,ALeA;AGRA,ADGA,AGTA,ALeA;AGRA,ADGA,AGTA,ALeA;AGRA,ADGA,AGTA,ALeA;AGRA,ADGA,AGTA,ALeA;AGRA,ADGA,AGTA,ALeA;AGRA,ADGA,AGTA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AGRA,AHSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar urllib = require('./urllib');\n\nexports.USER_AGENT = urllib.USER_AGENT;\nexports.TIMEOUT = urllib.TIMEOUT;\nexports.TIMEOUTS = urllib.TIMEOUTS;\nexports.agent = urllib.agent;\nexports.httpsAgent = urllib.httpsAgent;\n\nexports.curl = urllib.curl;\nexports.request = urllib.request;\nexports.requestWithCallback = urllib.requestWithCallback;\nexports.requestThunk = urllib.requestThunk;\n\nexports.HttpClient = require('./httpclient');\nexports.HttpClient2 = require('./httpclient2');\n\nexports.create = function (options) {\n  return new exports.HttpClient(options);\n};\n","\n\nvar debug = require('debug')('urllib');\nvar path = require('path');\nvar dns = require('dns');\nvar http = require('http');\nvar https = require('https');\nvar urlutil = require('url');\nvar URL = urlutil.URL;\nvar util = require('util');\nvar qs = require('qs');\nvar ip = require('ip');\nvar querystring = require('querystring');\nvar zlib = require('zlib');\nvar ua = require('default-user-agent');\nvar digestAuthHeader = require('digest-header');\nvar ms = require('humanize-ms');\nvar statuses = require('statuses');\nvar contentTypeParser = require('content-type');\nvar first = require('ee-first');\nvar pump = require('pump');\nvar utility = require('utility');\nvar FormStream = require('formstream');\nvar detectProxyAgent = require('./detect_proxy_agent');\n\nvar _Promise;\nvar _iconv;\n\nvar pkg = require('../package.json');\n\nvar USER_AGENT = exports.USER_AGENT = ua('node-urllib', pkg.version);\nvar NODE_MAJOR_VERSION = parseInt(process.versions.node.split('.')[0]);\n\n// change Agent.maxSockets to 1000\nexports.agent = new http.Agent();\nexports.agent.maxSockets = 1000;\n\nexports.httpsAgent = new https.Agent();\nexports.httpsAgent.maxSockets = 1000;\n\nvar LONG_STACK_DELIMITER = '\\n    --------------------\\n';\n\n/**\n * The default request timeout(in milliseconds).\n * @type {Number}\n * @const\n */\n\nexports.TIMEOUT = ms('5s');\nexports.TIMEOUTS = [ms('5s'), ms('5s')];\n\nvar REQUEST_ID = 0;\nvar MAX_VALUE = Math.pow(2, 31) - 10;\nvar isNode010 = /^v0\\.10\\.\\d+$/.test(process.version);\nvar isNode012 = /^v0\\.12\\.\\d+$/.test(process.version);\n\n/**\n * support data types\n * will auto decode response body\n * @type {Array}\n */\nvar TEXT_DATA_TYPES = [\n  'json',\n  'text'\n];\n\nvar PROTO_RE = /^https?:\\/\\//i;\n\n// Keep-Alive: timeout=5, max=100\nvar KEEP_ALIVE_RE = /^timeout=(\\d+)/i;\n\nvar SOCKET_REQUEST_COUNT = '_URLLIB_SOCKET_REQUEST_COUNT';\nvar SOCKET_RESPONSE_COUNT = '_URLLIB_SOCKET_RESPONSE_COUNT';\n\n/**\n * Handle all http request, both http and https support well.\n *\n * @example\n *\n * ```js\n * // GET https://nodejs.org\n * urllib.request('https://nodejs.org', function(err, data, res) {});\n * // POST https://nodejs.org\n * var args = { type: 'post', data: { foo: 'bar' } };\n * urllib.request('https://nodejs.org', args, function(err, data, res) {});\n * ```\n *\n * @param {String|Object} url: the request full URL.\n * @param {Object} [args]: optional\n *   - {Object} [data]: request data, will auto be query stringify.\n *   - {Boolean} [dataAsQueryString]: force convert `data` to query string.\n *   - {String|Buffer} [content]: optional, if set content, `data` will ignore.\n *   - {ReadStream} [stream]: read stream to sent.\n *   - {WriteStream} [writeStream]: writable stream to save response data.\n *       If you use this, callback's data should be null.\n *       We will just `pipe(ws, {end: true})`.\n *   - {consumeWriteStream} [true]: consume the writeStream, invoke the callback after writeStream close.\n *   - {Array<ReadStream|Buffer|String>|Object|ReadStream|Buffer|String} [files]: optional,\n *       The files will send with `multipart/form-data` format, base on `formstream`.\n *       If `method` not set, will use `POST` method by default.\n *   - {String} [method]: optional, could be GET | POST | DELETE | PUT, default is GET\n *   - {String} [contentType]: optional, request data type, could be `json`, default is undefined\n *   - {String} [dataType]: optional, response data type, could be `text` or `json`, default is buffer\n *   - {Boolean|Function} [fixJSONCtlChars]: optional, fix the control characters (U+0000 through U+001F)\n *       before JSON parse response. Default is `false`.\n *       `fixJSONCtlChars` can be a function, will pass data to the first argument. e.g.: `data = fixJSONCtlChars(data)`\n *   - {Object} [headers]: optional, request headers\n *   - {Number|Array} [timeout]: request timeout(in milliseconds), default is `exports.TIMEOUTS containing connect timeout and response timeout`\n *   - {Agent} [agent]: optional, http agent. Set `false` if you does not use agent.\n *   - {Agent} [httpsAgent]: optional, https agent. Set `false` if you does not use agent.\n *   - {String} [auth]: Basic authentication i.e. 'user:password' to compute an Authorization header.\n *   - {String} [digestAuth]: Digest authentication i.e. 'user:password' to compute an Authorization header.\n *   - {String|Buffer|Array} [ca]: An array of strings or Buffers of trusted certificates.\n *       If this is omitted several well known \"root\" CAs will be used, like VeriSign.\n *       These are used to authorize connections.\n *       Notes: This is necessary only if the server uses the self-signed certificate\n *   - {Boolean} [rejectUnauthorized]: If true, the server certificate is verified against the list of supplied CAs.\n *       An 'error' event is emitted if verification fails. Default: true.\n *   - {String|Buffer} [pfx]: A string or Buffer containing the private key,\n *       certificate and CA certs of the server in PFX or PKCS12 format.\n *   - {String|Buffer} [key]: A string or Buffer containing the private key of the client in PEM format.\n *       Notes: This is necessary only if using the client certificate authentication\n *   - {String|Buffer} [cert]: A string or Buffer containing the certificate key of the client in PEM format.\n *       Notes: This is necessary only if using the client certificate authentication\n *   - {String} [passphrase]: A string of passphrase for the private key or pfx.\n *   - {String} [ciphers]: A string describing the ciphers to use or exclude.\n *   - {String} [secureProtocol]: The SSL method to use, e.g. SSLv3_method to force SSL version 3.\n *       The possible values depend on your installation of OpenSSL and are defined in the constant SSL_METHODS.\n *   - {Boolean} [followRedirect]: Follow HTTP 3xx responses as redirects. defaults to false.\n *   - {Number} [maxRedirects]: The maximum number of redirects to follow, defaults to 10.\n *   - {Function(from, to)} [formatRedirectUrl]: Format the redirect url by your self. Default is `url.resolve(from, to)`\n *   - {Function(options)} [beforeRequest]: Before request hook, you can change every thing here.\n *   - {Boolean} [streaming]: let you get the res object when request connected, default is `false`. alias `customResponse`\n *   - {Boolean} [gzip]: Accept gzip response content and auto decode it, default is `false`.\n *   - {Boolean} [timing]: Enable timing or not, default is `false`.\n *   - {Function} [lookup]: Custom DNS lookup function, default is `dns.lookup`.\n *       Require node >= 4.0.0 and only work on `http` protocol.\n *   - {Boolean} [enableProxy]: optional, enable proxy request. Default is `false`.\n *   - {String|Object} [proxy]: optional proxy agent uri or options. Default is `null`.\n *   - {Function} checkAddress: optional, check request address to protect from SSRF and similar attacks.\n * @param {Function} [callback]: callback(error, data, res). If missing callback, will return a promise object.\n * @return {HttpRequest} req object.\n * @api public\n */\nexports.request = function request(url, args, callback) {\n  // request(url, callback)\n  if (arguments.length === 2 && typeof args === 'function') {\n    callback = args;\n    args = null;\n  }\n  if (typeof callback === 'function') {\n    return exports.requestWithCallback(url, args, callback);\n  }\n\n  // Promise\n  if (!_Promise) {\n    _Promise = require('any-promise');\n  }\n  return new _Promise(function (resolve, reject) {\n    exports.requestWithCallback(url, args, makeCallback(resolve, reject));\n  });\n};\n\n// alias to curl\nexports.curl = exports.request;\n\nfunction makeCallback(resolve, reject) {\n  return function (err, data, res) {\n    if (err) {\n      return reject(err);\n    }\n    resolve({\n      data: data,\n      status: res.statusCode,\n      headers: res.headers,\n      res: res\n    });\n  };\n}\n\n// yield urllib.requestThunk(url, args)\nexports.requestThunk = function requestThunk(url, args) {\n  return function (callback) {\n    exports.requestWithCallback(url, args, function (err, data, res) {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, {\n        data: data,\n        status: res.statusCode,\n        headers: res.headers,\n        res: res\n      });\n    });\n  };\n};\n\nfunction requestWithCallback(url, args, callback) {\n  // requestWithCallback(url, callback)\n  if (!url || (typeof url !== 'string' && typeof url !== 'object')) {\n    var msg = util.format('expect request url to be a string or a http request options, but got %j', url);\n    throw new Error(msg);\n  }\n\n  if (arguments.length === 2 && typeof args === 'function') {\n    callback = args;\n    args = null;\n  }\n\n  args = args || {};\n  if (REQUEST_ID >= MAX_VALUE) {\n    REQUEST_ID = 0;\n  }\n  var reqId = ++REQUEST_ID;\n\n  args.requestUrls = args.requestUrls || [];\n\n  args.timeout = args.timeout || exports.TIMEOUTS;\n  args.maxRedirects = args.maxRedirects || 10;\n  args.streaming = args.streaming || args.customResponse;\n  var requestStartTime = Date.now();\n  var parsedUrl;\n\n  if (typeof url === 'string') {\n    if (!PROTO_RE.test(url)) {\n      // Support `request('www.server.com')`\n      url = 'http://' + url;\n    }\n    if (URL) {\n      parsedUrl = urlutil.parse(new URL(url).href);\n    } else {\n      parsedUrl = urlutil.parse(url);\n    }\n  } else {\n    parsedUrl = url;\n  }\n\n  var reqMeta = {\n    requestId: reqId,\n    url: parsedUrl.href,\n    args: args,\n    ctx: args.ctx,\n  };\n  if (args.emitter) {\n    args.emitter.emit('request', reqMeta);\n  }\n\n  var method = (args.type || args.method || parsedUrl.method || 'GET').toUpperCase();\n  var port = parsedUrl.port || 80;\n  var httplib = http;\n  var agent = getAgent(args.agent, exports.agent);\n  var fixJSONCtlChars = args.fixJSONCtlChars;\n\n  if (parsedUrl.protocol === 'https:') {\n    httplib = https;\n    agent = getAgent(args.httpsAgent, exports.httpsAgent);\n\n    if (!parsedUrl.port) {\n      port = 443;\n    }\n  }\n\n  // request through proxy tunnel\n  var proxyTunnelAgent = detectProxyAgent(parsedUrl, args);\n  if (proxyTunnelAgent) {\n    agent = proxyTunnelAgent;\n  }\n\n  var lookup = args.lookup;\n  // check address to protect from SSRF and similar attacks\n  if (args.checkAddress) {\n    var _lookup = lookup || dns.lookup;\n    lookup = function(host, dnsopts, callback) {\n      _lookup(host, dnsopts, function emitLookup(err, ip, family) {\n        // add check address logic in custom dns lookup\n        if (!err && !args.checkAddress(ip, family)) {\n          err = new Error('illegal address');\n          err.name = 'IllegalAddressError';\n          err.hostname = host;\n          err.ip = ip;\n          err.family = family;\n        }\n        callback(err, ip, family);\n      });\n    };\n  }\n\n  var requestSize = 0;\n  var options = {\n    host: parsedUrl.hostname || parsedUrl.host || 'localhost',\n    path: parsedUrl.path || '/',\n    method: method,\n    port: port,\n    agent: agent,\n    headers: {},\n    // default is dns.lookup\n    // https://github.com/nodejs/node/blob/master/lib/net.js#L986\n    // custom dnslookup require node >= 4.0.0 (for http), node >=8 (for https)\n    // https://github.com/nodejs/node/blob/archived-io.js-v0.12/lib/net.js#L952\n    lookup: lookup,\n  };\n  if (args.headers) {\n    // only allow enumerable and ownProperty value of args.headers\n    var names = utility.getOwnEnumerables(args.headers, true);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      options.headers[name] = args.headers[name];\n    }\n  }\n\n  var sslNames = [\n    'pfx',\n    'key',\n    'passphrase',\n    'cert',\n    'ca',\n    'ciphers',\n    'rejectUnauthorized',\n    'secureProtocol',\n    'secureOptions',\n  ];\n  for (var i = 0; i < sslNames.length; i++) {\n    var name = sslNames[i];\n    if (args.hasOwnProperty(name)) {\n      options[name] = args[name];\n    }\n  }\n\n  // fix rejectUnauthorized when major version < 12\n  if (NODE_MAJOR_VERSION < 12) {\n    if (options.rejectUnauthorized === false && !options.hasOwnProperty('secureOptions')) {\n      options.secureOptions = require('constants').SSL_OP_NO_TLSv1_2;\n    }\n  }\n\n  var auth = args.auth || parsedUrl.auth;\n  if (auth) {\n    options.auth = auth;\n  }\n\n  var body = null;\n  var dataAsQueryString = false;\n\n  if (args.files) {\n    if (!options.method || options.method === 'GET' || options.method === 'HEAD') {\n      options.method = 'POST';\n    }\n    var files = args.files;\n    var uploadFiles = [];\n    if (Array.isArray(files)) {\n      for (var i = 0; i < files.length; i++) {\n        var field = 'file' + (i === 0 ? '' : i);\n        uploadFiles.push([ field, files[i] ]);\n      }\n    } else {\n      if (Buffer.isBuffer(files) || typeof files.pipe === 'function' || typeof files === 'string') {\n        uploadFiles.push([ 'file', files ]);\n      } else if (typeof files === 'object') {\n        for (var field in files) {\n          uploadFiles.push([ field, files[field] ]);\n        }\n      }\n    }\n    var form = new FormStream();\n    // set normal fields first\n    if (args.data) {\n      for (var fieldName in args.data) {\n        form.field(fieldName, args.data[fieldName]);\n      }\n    }\n\n    for (var i = 0; i < uploadFiles.length; i++) {\n      var item = uploadFiles[i];\n      if (Buffer.isBuffer(item[1])) {\n        form.buffer(item[0], item[1], 'bufferfile' + i);\n      } else if (typeof item[1].pipe === 'function') {\n        var filename = item[1].path || ('streamfile' + i);\n        filename = path.basename(filename);\n        form.stream(item[0], item[1], filename);\n      } else {\n        form.file(item[0], item[1]);\n      }\n    }\n\n    var formHeaders = form.headers();\n    var formHeaderNames = utility.getOwnEnumerables(formHeaders, true);\n    for (var i = 0; i < formHeaderNames.length; i++) {\n      var name = formHeaderNames[i];\n      options.headers[name] = formHeaders[name];\n    }\n    debug('set multipart headers: %j, method: %s', formHeaders, options.method);\n    args.stream = form;\n  } else {\n    body = args.content || args.data;\n    dataAsQueryString = method === 'GET' || method === 'HEAD' || args.dataAsQueryString;\n    if (!args.content) {\n      if (body && !(typeof body === 'string' || Buffer.isBuffer(body))) {\n        if (dataAsQueryString) {\n          // read: GET, HEAD, use query string\n          body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);\n        } else {\n          var contentType = options.headers['Content-Type'] || options.headers['content-type'];\n          // auto add application/x-www-form-urlencoded when using urlencode form request\n          if (!contentType) {\n            if (args.contentType === 'json') {\n              contentType = 'application/json';\n            } else {\n              contentType = 'application/x-www-form-urlencoded';\n            }\n            options.headers['Content-Type'] = contentType;\n          }\n\n          if (parseContentType(contentType).type === 'application/json') {\n            body = JSON.stringify(body);\n          } else {\n            // 'application/x-www-form-urlencoded'\n            body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);\n          }\n        }\n      }\n    }\n  }\n\n  if (body) {\n    // if it's a GET or HEAD request, data should be sent as query string\n    if (dataAsQueryString) {\n      options.path += (parsedUrl.query ? '&' : '?') + body;\n      body = null;\n    }\n\n    if (body) {\n      var length = body.length;\n      if (!Buffer.isBuffer(body)) {\n        length = Buffer.byteLength(body);\n      }\n      requestSize = options.headers['Content-Length'] = length;\n    }\n  }\n\n  if (args.dataType === 'json') {\n    if (!options.headers.Accept && !options.headers.accept) {\n      options.headers.Accept = 'application/json';\n    }\n  }\n\n  if (typeof args.beforeRequest === 'function') {\n    // you can use this hook to change every thing.\n    args.beforeRequest(options);\n  }\n  var connectTimer = null;\n  var responseTimer = null;\n  var __err = null;\n  var connected = false; // socket connected or not\n  var keepAliveSocket = false; // request with keepalive socket\n  var socketHandledRequests = 0; // socket already handled request count\n  var socketHandledResponses = 0; // socket already handled response count\n  var responseSize = 0;\n  var statusCode = -1;\n  var statusMessage = null;\n  var responseAborted = false;\n  var remoteAddress = '';\n  var remotePort = '';\n  var timing = null;\n  if (args.timing) {\n    timing = {\n      // socket assigned\n      queuing: 0,\n      // dns lookup time\n      dnslookup: 0,\n      // socket connected\n      connected: 0,\n      // request sent\n      requestSent: 0,\n      // Time to first byte (TTFB)\n      waiting: 0,\n      contentDownload: 0,\n    };\n  }\n\n  function cancelConnectTimer() {\n    if (connectTimer) {\n      clearTimeout(connectTimer);\n      connectTimer = null;\n      debug('Request#%d connect timer canceled', reqId);\n    }\n  }\n  function cancelResponseTimer() {\n    if (responseTimer) {\n      clearTimeout(responseTimer);\n      responseTimer = null;\n      debug('Request#%d response timer canceled', reqId);\n    }\n  }\n\n  function done(err, data, res) {\n    cancelConnectTimer();\n    cancelResponseTimer();\n    if (!callback) {\n      console.warn('[urllib:warn] [%s] [%s] [worker:%s] %s %s callback twice!!!',\n        Date(), reqId, process.pid, options.method, url);\n      // https://github.com/node-modules/urllib/pull/30\n      if (err) {\n        console.warn('[urllib:warn] [%s] [%s] [worker:%s] %s: %s\\nstack: %s',\n          Date(), reqId, process.pid, err.name, err.message, err.stack);\n      }\n      return;\n    }\n    var cb = callback;\n    callback = null;\n    var headers = {};\n    if (res) {\n      statusCode = res.statusCode;\n      statusMessage = res.statusMessage;\n      headers = res.headers;\n    }\n\n    // handle digest auth\n    if (statusCode === 401 && headers['www-authenticate']\n        && !options.headers.Authorization && args.digestAuth) {\n      var authenticate = headers['www-authenticate'];\n      if (authenticate.indexOf('Digest ') >= 0) {\n        debug('Request#%d %s: got digest auth header WWW-Authenticate: %s', reqId, url, authenticate);\n        options.headers.Authorization = digestAuthHeader(options.method, options.path, authenticate, args.digestAuth);\n        debug('Request#%d %s: auth with digest header: %s', reqId, url, options.headers.Authorization);\n        if (res.headers['set-cookie']) {\n          options.headers.Cookie = res.headers['set-cookie'].join(';');\n        }\n        args.headers = options.headers;\n        return exports.requestWithCallback(url, args, cb);\n      }\n    }\n\n    var requestUseTime = Date.now() - requestStartTime;\n    if (timing) {\n      timing.contentDownload = requestUseTime;\n    }\n\n    debug('[%sms] done, %s bytes HTTP %s %s %s %s, keepAliveSocket: %s, timing: %j, socketHandledRequests: %s, socketHandledResponses: %s',\n      requestUseTime, responseSize, statusCode, options.method, options.host, options.path,\n      keepAliveSocket, timing, socketHandledRequests, socketHandledResponses);\n\n    var response = {\n      status: statusCode,\n      statusCode: statusCode,\n      statusMessage: statusMessage,\n      headers: headers,\n      size: responseSize,\n      aborted: responseAborted,\n      rt: requestUseTime,\n      keepAliveSocket: keepAliveSocket,\n      data: data,\n      requestUrls: args.requestUrls,\n      timing: timing,\n      remoteAddress: remoteAddress,\n      remotePort: remotePort,\n      socketHandledRequests: socketHandledRequests,\n      socketHandledResponses: socketHandledResponses,\n    };\n\n    if (err) {\n      var agentStatus = '';\n      if (agent && typeof agent.getCurrentStatus === 'function') {\n        // add current agent status to error message for logging and debug\n        agentStatus = ', agent status: ' + JSON.stringify(agent.getCurrentStatus());\n      }\n      err.message += ', ' + options.method + ' ' + url + ' ' + statusCode\n        + ' (connected: ' + connected + ', keepalive socket: ' + keepAliveSocket + agentStatus\n        + ', socketHandledRequests: ' + socketHandledRequests\n        + ', socketHandledResponses: ' + socketHandledResponses + ')'\n        + '\\nheaders: ' + JSON.stringify(headers);\n      err.data = data;\n      err.path = options.path;\n      err.status = statusCode;\n      err.headers = headers;\n      err.res = response;\n      addLongStackTrace(err, req);\n    }\n\n    // only support agentkeepalive module for now\n    // agentkeepalive@4: agent.options.freeSocketTimeout\n    // agentkeepalive@3: agent.freeSocketKeepAliveTimeout\n    var freeSocketTimeout = agent && (agent.options && agent.options.freeSocketTimeout || agent.freeSocketKeepAliveTimeout);\n    if (agent && agent.keepAlive && freeSocketTimeout > 0 &&\n        statusCode >= 200 && headers.connection === 'keep-alive' && headers['keep-alive']) {\n      // adjust freeSocketTimeout on the socket\n      var m = KEEP_ALIVE_RE.exec(headers['keep-alive']);\n      if (m) {\n        var seconds = parseInt(m[1]);\n        if (seconds > 0) {\n          // network delay 500ms\n          var serverSocketTimeout = seconds * 1000 - 500;\n          if (serverSocketTimeout < freeSocketTimeout) {\n            // https://github.com/node-modules/agentkeepalive/blob/master/lib/agent.js#L127\n            // agentkeepalive@4\n            if (agent.options && agent.options.freeSocketTimeout) {\n              res.socket.freeSocketTimeout = serverSocketTimeout;\n            } else {\n              res.socket.freeSocketKeepAliveTimeout = serverSocketTimeout;\n            }\n          }\n        }\n      }\n    }\n\n    cb(err, data, args.streaming ? res : response);\n\n    if (args.emitter) {\n      // keep to use the same reqMeta object on request event before\n      reqMeta.url = parsedUrl.href;\n      reqMeta.socket = req && req.connection;\n      reqMeta.options = options;\n      reqMeta.size = requestSize;\n\n      args.emitter.emit('response', {\n        requestId: reqId,\n        error: err,\n        ctx: args.ctx,\n        req: reqMeta,\n        res: response,\n      });\n    }\n  }\n\n  function handleRedirect(res) {\n    var err = null;\n    if (args.followRedirect && statuses.redirect[res.statusCode]) {  // handle redirect\n      args._followRedirectCount = (args._followRedirectCount || 0) + 1;\n      var location = res.headers.location;\n      if (!location) {\n        err = new Error('Got statusCode ' + res.statusCode + ' but cannot resolve next location from headers');\n        err.name = 'FollowRedirectError';\n      } else if (args._followRedirectCount > args.maxRedirects) {\n        err = new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + url);\n        err.name = 'MaxRedirectError';\n      } else {\n        var newUrl = args.formatRedirectUrl ? args.formatRedirectUrl(url, location) : urlutil.resolve(url, location);\n        debug('Request#%d %s: `redirected` from %s to %s', reqId, options.path, url, newUrl);\n        // make sure timer stop\n        cancelResponseTimer();\n        // should clean up headers.Host on `location: http://other-domain/url`\n        if (options.headers.Host && PROTO_RE.test(location)) {\n          options.headers.Host = null;\n          args.headers = options.headers;\n        }\n        // avoid done will be execute in the future change.\n        var cb = callback;\n        callback = null;\n        exports.requestWithCallback(newUrl, args, cb);\n        return {\n          redirect: true,\n          error: null\n        };\n      }\n    }\n    return {\n      redirect: false,\n      error: err\n    };\n  }\n\n  // don't set user-agent\n  if (args.headers && (args.headers['User-Agent'] === null || args.headers['user-agent'] === null)) {\n    if (options.headers['user-agent']) {\n      delete options.headers['user-agent'];\n    }\n    if (options.headers['User-Agent']) {\n      delete options.headers['User-Agent'];\n    }\n  } else {\n    // need to set user-agent\n    var hasAgentHeader = options.headers['User-Agent'] || options.headers['user-agent'];\n    if (!hasAgentHeader) {\n      options.headers['User-Agent'] = USER_AGENT;\n    }\n  }\n\n  if (args.gzip) {\n    var isAcceptEncodingNull = (args.headers && (args.headers['Accept-Encoding'] === null || args.headers['accept-encoding'] === null));\n    if (!isAcceptEncodingNull) {\n      var hasAcceptEncodingHeader = options.headers['Accept-Encoding'] || options.headers['accept-encoding'];\n      if (!hasAcceptEncodingHeader) {\n        options.headers['Accept-Encoding'] = 'gzip, deflate';\n      }\n    }\n  }\n\n  function decodeContent(res, body, cb) {\n    var encoding = res.headers['content-encoding'];\n    if (body.length === 0 || !encoding) {\n      return cb(null, body, encoding);\n    }\n\n    encoding = encoding.toLowerCase();\n    switch (encoding) {\n      case 'gzip':\n      case 'deflate':\n        debug('unzip %d length body', body.length);\n        zlib.unzip(body, function(err, data) {\n          if (err && err.name === 'Error') {\n            err.name = 'UnzipError';\n          }\n          cb(err, data);\n        });\n        break;\n      default:\n        cb(null, body, encoding);\n    }\n  }\n\n  var writeStream = args.writeStream;\n  var isWriteStreamClose = false;\n\n  debug('Request#%d %s %s with headers %j, options.path: %s',\n    reqId, method, url, options.headers, options.path);\n\n  args.requestUrls.push(parsedUrl.href);\n\n  function onResponse(res) {\n    socketHandledResponses = res.socket[SOCKET_RESPONSE_COUNT] = (res.socket[SOCKET_RESPONSE_COUNT] || 0) + 1;\n    if (timing) {\n      timing.waiting = Date.now() - requestStartTime;\n    }\n    debug('Request#%d %s `req response` event emit: status %d, headers: %j',\n      reqId, url, res.statusCode, res.headers);\n\n    if (args.streaming) {\n      var result = handleRedirect(res);\n      if (result.redirect) {\n        res.resume();\n        return;\n      }\n      if (result.error) {\n        res.resume();\n        return done(result.error, null, res);\n      }\n\n      return done(null, null, res);\n    }\n\n    res.on('close', function () {\n      debug('Request#%d %s: `res close` event emit, total size %d, socket handled %s requests and %s responses',\n        reqId, url, responseSize, socketHandledRequests, socketHandledResponses);\n    });\n\n    res.on('error', function () {\n      debug('Request#%d %s: `res error` event emit, total size %d, socket handled %s requests and %s responses',\n        reqId, url, responseSize, socketHandledRequests, socketHandledResponses);\n    });\n\n    res.on('aborted', function () {\n      responseAborted = true;\n      debug('Request#%d %s: `res aborted` event emit, total size %d',\n        reqId, url, responseSize);\n    });\n\n    if (writeStream) {\n      // If there's a writable stream to recieve the response data, just pipe the\n      // response stream to that writable stream and call the callback when it has\n      // finished writing.\n      //\n      // NOTE that when the response stream `res` emits an 'end' event it just\n      // means that it has finished piping data to another stream. In the\n      // meanwhile that writable stream may still writing data to the disk until\n      // it emits a 'close' event.\n      //\n      // That means that we should not apply callback until the 'close' of the\n      // writable stream is emited.\n      //\n      // See also:\n      // - https://github.com/TBEDP/urllib/commit/959ac3365821e0e028c231a5e8efca6af410eabb\n      // - http://nodejs.org/api/stream.html#stream_event_end\n      // - http://nodejs.org/api/stream.html#stream_event_close_1\n      var result = handleRedirect(res);\n      if (result.redirect) {\n        res.resume();\n        return;\n      }\n      if (result.error) {\n        res.resume();\n        // end ths stream first\n        writeStream.end();\n        done(result.error, null, res);\n        return;\n      }\n\n      // you can set consumeWriteStream false that only wait response end\n      if (args.consumeWriteStream === false) {\n        res.on('end', done.bind(null, null, null, res));\n        pump(res, writeStream, function(err) {\n          if (isWriteStreamClose) {\n            return;\n          }\n          isWriteStreamClose = true;\n          debug('Request#%d %s: writeStream close, error: %s', reqId, url, err);\n        });\n        return;\n      }\n\n      // node 0.10, 0.12: only emit res aborted, writeStream close not fired\n      if (isNode010 || isNode012) {\n        first([\n          [ writeStream, 'close' ],\n          [ res, 'aborted' ],\n        ], function(_, stream, event) {\n          debug('Request#%d %s: writeStream or res %s event emitted', reqId, url, event);\n          done(__err || null, null, res);\n        });\n        res.pipe(writeStream);\n        return;\n      }\n\n      debug('Request#%d %s: pump res to writeStream', reqId, url);\n      pump(res, writeStream, function(err) {\n        debug('Request#%d %s: writeStream close event emitted, error: %s, isWriteStreamClose: %s',\n          reqId, url, err, isWriteStreamClose);\n        if (isWriteStreamClose) {\n          return;\n        }\n        isWriteStreamClose = true;\n        done(__err || err, null, res);\n      });\n      return;\n    }\n\n    // Otherwise, just concat those buffers.\n    //\n    // NOTE that the `chunk` is not a String but a Buffer. It means that if\n    // you simply concat two chunk with `+` you're actually converting both\n    // Buffers into Strings before concating them. It'll cause problems when\n    // dealing with multi-byte characters.\n    //\n    // The solution is to store each chunk in an array and concat them with\n    // 'buffer-concat' when all chunks is recieved.\n    //\n    // See also:\n    // http://cnodejs.org/topic/4faf65852e8fb5bc65113403\n\n    var chunks = [];\n\n    res.on('data', function (chunk) {\n      debug('Request#%d %s: `res data` event emit, size %d', reqId, url, chunk.length);\n      responseSize += chunk.length;\n      chunks.push(chunk);\n    });\n\n    res.on('end', function () {\n      var body = Buffer.concat(chunks, responseSize);\n      debug('Request#%d %s: `res end` event emit, total size %d, _dumped: %s',\n        reqId, url, responseSize, res._dumped);\n\n      if (__err) {\n        // req.abort() after `res data` event emit.\n        return done(__err, body, res);\n      }\n\n      var result = handleRedirect(res);\n      if (result.error) {\n        return done(result.error, body, res);\n      }\n      if (result.redirect) {\n        return;\n      }\n\n      decodeContent(res, body, function (err, data, encoding) {\n        if (err) {\n          return done(err, body, res);\n        }\n        // if body not decode, dont touch it\n        if (!encoding && TEXT_DATA_TYPES.indexOf(args.dataType) >= 0) {\n          // try to decode charset\n          try {\n            data = decodeBodyByCharset(data, res);\n          } catch (e) {\n            debug('decodeBodyByCharset error: %s', e);\n            // if error, dont touch it\n            return done(null, data, res);\n          }\n\n          if (args.dataType === 'json') {\n            if (responseSize === 0) {\n              data = null;\n            } else {\n              var r = parseJSON(data, fixJSONCtlChars);\n              if (r.error) {\n                err = r.error;\n              } else {\n                data = r.data;\n              }\n            }\n          }\n        }\n\n        if (responseAborted) {\n          // err = new Error('Remote socket was terminated before `response.end()` was called');\n          // err.name = 'RemoteSocketClosedError';\n          debug('Request#%d %s: Remote socket was terminated before `response.end()` was called', reqId, url);\n        }\n\n        done(err, data, res);\n      });\n    });\n  }\n\n  var connectTimeout, responseTimeout;\n  if (Array.isArray(args.timeout)) {\n    connectTimeout = ms(args.timeout[0]);\n    responseTimeout = ms(args.timeout[1]);\n  } else {  // set both timeout equal\n    connectTimeout = responseTimeout = ms(args.timeout);\n  }\n  debug('ConnectTimeout: %d, ResponseTimeout: %d', connectTimeout, responseTimeout);\n\n  function startConnectTimer() {\n    debug('Connect timer ticking, timeout: %d', connectTimeout);\n    connectTimer = setTimeout(function () {\n      connectTimer = null;\n      if (statusCode === -1) {\n        statusCode = -2;\n      }\n      var msg = 'Connect timeout for ' + connectTimeout + 'ms';\n      var errorName = 'ConnectionTimeoutError';\n      if (!req.socket) {\n        errorName = 'SocketAssignTimeoutError';\n        msg += ', working sockets is full';\n      }\n      __err = new Error(msg);\n      __err.name = errorName;\n      __err.requestId = reqId;\n      debug('ConnectTimeout: Request#%d %s %s: %s, connected: %s', reqId, url, __err.name, msg, connected);\n      abortRequest();\n    }, connectTimeout);\n  }\n\n  function startResposneTimer() {\n    debug('Response timer ticking, timeout: %d', responseTimeout);\n    responseTimer = setTimeout(function () {\n      responseTimer = null;\n      var msg = 'Response timeout for ' + responseTimeout + 'ms';\n      var errorName = 'ResponseTimeoutError';\n      __err = new Error(msg);\n      __err.name = errorName;\n      __err.requestId = reqId;\n      debug('ResponseTimeout: Request#%d %s %s: %s, connected: %s', reqId, url, __err.name, msg, connected);\n      abortRequest();\n    }, responseTimeout);\n  }\n\n  if (args.checkAddress) {\n    var hostname = parsedUrl.hostname;\n    // if request hostname is ip, custom lookup wont excute\n    var family = null;\n    if (ip.isV4Format(hostname)) {\n      family = 4;\n    } else if (ip.isV6Format(hostname)) {\n      family = 6;\n    }\n    if (family) {\n      if (!args.checkAddress(hostname, family)) {\n        var err = new Error('illegal address');\n        err.name = 'IllegalAddressError';\n        err.hostname = hostname;\n        err.ip = hostname;\n        err.family = family;\n        return done(err);\n      }\n    }\n  }\n\n  var req;\n  // request headers checker will throw error\n  try {\n    req = httplib.request(options, onResponse);\n    if (args.trace) {\n      req._callSite = {};\n      Error.captureStackTrace(req._callSite, requestWithCallback);\n    }\n  } catch (err) {\n    return done(err);\n  }\n\n  // environment detection: browser or nodejs\n  if (typeof(window) === 'undefined') {\n    // start connect timer just after `request` return, and just in nodejs environment\n    startConnectTimer();\n  }\n\n  var isRequestAborted = false;\n  function abortRequest() {\n    if (isRequestAborted) {\n      return;\n    }\n    isRequestAborted = true;\n\n    debug('Request#%d %s abort, connected: %s', reqId, url, connected);\n    // it wont case error event when req haven't been assigned a socket yet.\n    if (!req.socket) {\n      __err.noSocket = true;\n      done(__err);\n    }\n    req.abort();\n  }\n\n  if (timing) {\n    // request sent\n    req.on('finish', function() {\n      timing.requestSent = Date.now() - requestStartTime;\n    });\n  }\n\n  req.once('socket', function (socket) {\n    if (timing) {\n      // socket queuing time\n      timing.queuing = Date.now() - requestStartTime;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/net.js#L377\n    // https://github.com/nodejs/node/blob/v0.10.40-release/lib/net.js#L352\n    // should use socket.socket on 0.10.x\n    if (isNode010 && socket.socket) {\n      socket = socket.socket;\n    }\n\n    var orginalSocketTimeout = getSocketTimeout(socket);\n    if (orginalSocketTimeout && orginalSocketTimeout < responseTimeout) {\n      // make sure socket live longer than the response timer\n      var socketTimeout = responseTimeout + 500;\n      debug('Request#%d socket.timeout(%s) < responseTimeout(%s), reset socket timeout to %s',\n        reqId, orginalSocketTimeout, responseTimeout, socketTimeout);\n      socket.setTimeout(socketTimeout);\n    }\n\n    socketHandledRequests = socket[SOCKET_REQUEST_COUNT] = (socket[SOCKET_REQUEST_COUNT] || 0) + 1;\n    if (socket[SOCKET_RESPONSE_COUNT]) {\n      socketHandledResponses = socket[SOCKET_RESPONSE_COUNT];\n    }\n\n    var readyState = socket.readyState;\n    if (readyState === 'opening') {\n      socket.once('lookup', function(err, ip, addressType) {\n        debug('Request#%d %s lookup: %s, %s, %s', reqId, url, err, ip, addressType);\n        if (timing) {\n          timing.dnslookup = Date.now() - requestStartTime;\n        }\n        if (ip) {\n          remoteAddress = ip;\n        }\n      });\n      socket.once('connect', function() {\n        if (timing) {\n          // socket connected\n          timing.connected = Date.now() - requestStartTime;\n        }\n\n        // cancel socket timer at first and start tick for TTFB\n        cancelConnectTimer();\n        startResposneTimer();\n\n        debug('Request#%d %s new socket connected', reqId, url);\n        connected = true;\n        if (!remoteAddress) {\n          remoteAddress = socket.remoteAddress;\n        }\n        remotePort = socket.remotePort;\n      });\n      return;\n    }\n\n    debug('Request#%d %s reuse socket connected, readyState: %s', reqId, url, readyState);\n    connected = true;\n    keepAliveSocket = true;\n    if (!remoteAddress) {\n      remoteAddress = socket.remoteAddress;\n    }\n    remotePort = socket.remotePort;\n\n    // reuse socket, timer should be canceled.\n    cancelConnectTimer();\n    startResposneTimer();\n  });\n\n  if (writeStream) {\n    writeStream.once('error', function(err) {\n      err.message += ' (writeStream \"error\")';\n      __err = err;\n      debug('Request#%d %s `writeStream error` event emit, %s: %s', reqId, url, err.name, err.message);\n      abortRequest();\n    });\n  }\n\n  var isRequestError = false;\n  function handleRequestError(err) {\n    if (isRequestError || !err) {\n      return;\n    }\n    isRequestError = true;\n\n    if (err.name === 'Error') {\n      err.name = connected ? 'ResponseError' : 'RequestError';\n    }\n    debug('Request#%d %s `req error` event emit, %s: %s', reqId, url, err.name, err.message);\n    done(__err || err);\n  }\n  if (args.stream) {\n    debug('Request#%d pump args.stream to req', reqId);\n    pump(args.stream, req, handleRequestError);\n  } else {\n    req.end(body);\n  }\n  // when stream already consumed, req's `finish` event is emitted and pump will ignore error after pipe finished\n  // but if server response timeout later, we will abort the request and emit an error in req\n  // so we must always manually listen to req's `error` event here to ensure this error is handled\n  req.on('error', handleRequestError);\n  req.requestId = reqId;\n  return req;\n}\n\nexports.requestWithCallback = requestWithCallback;\n\nvar JSONCtlCharsMap = {\n  '\"': '\\\\\"',       // \\u0022\n  '\\\\': '\\\\\\\\',     // \\u005c\n  '\\b': '\\\\b',      // \\u0008\n  '\\f': '\\\\f',      // \\u000c\n  '\\n': '\\\\n',      // \\u000a\n  '\\r': '\\\\r',      // \\u000d\n  '\\t': '\\\\t'       // \\u0009\n};\nvar JSONCtlCharsRE = /[\\u0000-\\u001F\\u005C]/g;\n\nfunction _replaceOneChar(c) {\n  return JSONCtlCharsMap[c] || '\\\\u' + (c.charCodeAt(0) + 0x10000).toString(16).substr(1);\n}\n\nfunction replaceJSONCtlChars(str) {\n  return str.replace(JSONCtlCharsRE, _replaceOneChar);\n}\n\nfunction parseJSON(data, fixJSONCtlChars) {\n  var result = {\n    error: null,\n    data: null\n  };\n  if (fixJSONCtlChars) {\n    if (typeof fixJSONCtlChars === 'function') {\n      data = fixJSONCtlChars(data);\n    } else {\n      // https://github.com/node-modules/urllib/pull/77\n      // remote the control characters (U+0000 through U+001F)\n      data = replaceJSONCtlChars(data);\n    }\n  }\n  try {\n    result.data = JSON.parse(data);\n  } catch (err) {\n    if (err.name === 'SyntaxError') {\n      err.name = 'JSONResponseFormatError';\n    }\n    if (data.length > 1024) {\n      // show 0~512 ... -512~end data\n      err.message += ' (data json format: ' +\n        JSON.stringify(data.slice(0, 512)) + ' ...skip... ' + JSON.stringify(data.slice(data.length - 512)) + ')';\n    } else {\n      err.message += ' (data json format: ' + JSON.stringify(data) + ')';\n    }\n    result.error = err;\n  }\n  return result;\n}\n\n\n/**\n * decode response body by parse `content-type`'s charset\n * @param {Buffer} data\n * @param {Http(s)Response} res\n * @return {String}\n */\nfunction decodeBodyByCharset(data, res) {\n  var type = res.headers['content-type'];\n  if (!type) {\n    return data.toString();\n  }\n\n  var type = parseContentType(type);\n  var charset = type.parameters.charset || 'utf-8';\n\n  if (!Buffer.isEncoding(charset)) {\n    if (!_iconv) {\n      _iconv = require('iconv-lite');\n    }\n    return _iconv.decode(data, charset);\n  }\n\n  return data.toString(charset);\n}\n\nfunction getAgent(agent, defaultAgent) {\n  return agent === undefined ? defaultAgent : agent;\n}\n\nfunction parseContentType(str) {\n  try {\n    return contentTypeParser.parse(str);\n  } catch (err) {\n    // ignore content-type error, tread as default\n    return { parameters: {} };\n  }\n}\n\nfunction addLongStackTrace(err, req) {\n  if (!req) {\n    return;\n  }\n  var callSiteStack = req._callSite && req._callSite.stack;\n  if (!callSiteStack || typeof callSiteStack !== 'string') {\n    return;\n  }\n  if (err._longStack) {\n    return;\n  }\n  var index = callSiteStack.indexOf('\\n');\n  if (index !== -1) {\n    err._longStack = true;\n    err.stack += LONG_STACK_DELIMITER + callSiteStack.substr(index + 1);\n  }\n}\n\n// node 8 don't has timeout attribute on socket\n// https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\nfunction getSocketTimeout(socket) {\n  return socket.timeout || socket._idleTimeout;\n}\n","\n\nvar debug = require('debug')('urllib:detect_proxy_agent');\nvar getProxyFromURI = require('./get_proxy_from_uri');\n\nvar proxyAgents = {};\n\nfunction detectProxyAgent(uri, args) {\n  if (!args.enableProxy && !process.env.URLLIB_ENABLE_PROXY) {\n    return null;\n  }\n  var proxy = args.proxy || process.env.URLLIB_PROXY;\n  if (!proxy) {\n    proxy = getProxyFromURI(uri);\n    if (!proxy) {\n      return null;\n    }\n  }\n\n  var proxyAgent = proxyAgents[proxy];\n  if (!proxyAgent) {\n    debug('create new proxy %s', proxy);\n    // lazy require, only support node >= 4\n    proxyAgent = proxyAgents[proxy] = new (require('proxy-agent'))(proxy);\n  }\n  debug('get proxy: %s', proxy);\n  return proxyAgent;\n}\n\nmodule.exports = detectProxyAgent;\nmodule.exports.proxyAgents = proxyAgents;\n","// copy from https://github.com/request/request/blob/90cf8c743bb9fd6a4cb683a56fb7844c6b316866/lib/getProxyFromURI.js\n\n\n\nfunction formatHostname(hostname) {\n  // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'\n  return hostname.replace(/^\\.*/, '.').toLowerCase()\n}\n\nfunction parseNoProxyZone(zone) {\n  zone = zone.trim().toLowerCase()\n\n  var zoneParts = zone.split(':', 2)\n    , zoneHost = formatHostname(zoneParts[0])\n    , zonePort = zoneParts[1]\n    , hasPort = zone.indexOf(':') > -1\n\n  return {hostname: zoneHost, port: zonePort, hasPort: hasPort}\n}\n\nfunction uriInNoProxy(uri, noProxy) {\n  var port = uri.port || (uri.protocol === 'https:' ? '443' : '80')\n    , hostname = formatHostname(uri.hostname)\n    , noProxyList = noProxy.split(',')\n\n  // iterate through the noProxyList until it finds a match.\n  return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {\n    var isMatchedAt = hostname.indexOf(noProxyZone.hostname)\n      , hostnameMatched = (\n          isMatchedAt > -1 &&\n          (isMatchedAt === hostname.length - noProxyZone.hostname.length)\n        )\n\n    if (noProxyZone.hasPort) {\n      return (port === noProxyZone.port) && hostnameMatched\n    }\n\n    return hostnameMatched\n  })\n}\n\nfunction getProxyFromURI(uri) {\n  // Decide the proper request proxy to use based on the request URI object and the\n  // environmental variables (NO_PROXY, HTTP_PROXY, etc.)\n  // respect NO_PROXY environment variables (see: http://lynx.isc.org/current/breakout/lynx_help/keystrokes/environments.html)\n\n  var noProxy = process.env.NO_PROXY || process.env.no_proxy || ''\n\n  // if the noProxy is a wildcard then return null\n\n  if (noProxy === '*') {\n    return null\n  }\n\n  // if the noProxy is not empty and the uri is found return null\n\n  if (noProxy !== '' && uriInNoProxy(uri, noProxy)) {\n    return null\n  }\n\n  // Check for HTTP or HTTPS Proxy in environment Else default to null\n\n  if (uri.protocol === 'http:') {\n    return process.env.HTTP_PROXY ||\n           process.env.http_proxy || null\n  }\n\n  if (uri.protocol === 'https:') {\n    return process.env.HTTPS_PROXY ||\n           process.env.https_proxy ||\n           process.env.HTTP_PROXY  ||\n           process.env.http_proxy  || null\n  }\n\n  // if none of that works, return null\n  // (What uri protocol are you using then?)\n\n  return null\n}\n\nmodule.exports = getProxyFromURI\n","module.exports = {\n  \"_from\": \"urllib@^2.33.0\",\n  \"_id\": \"urllib@2.34.2\",\n  \"_inBundle\": false,\n  \"_integrity\": \"sha1-zo3a/esipAJlCUwaqWG8vnyGYrg=\",\n  \"_location\": \"/urllib\",\n  \"_phantomChildren\": {},\n  \"_requested\": {\n    \"type\": \"range\",\n    \"registry\": true,\n    \"raw\": \"urllib@^2.33.0\",\n    \"name\": \"urllib\",\n    \"escapedName\": \"urllib\",\n    \"rawSpec\": \"^2.33.0\",\n    \"saveSpec\": null,\n    \"fetchSpec\": \"^2.33.0\"\n  },\n  \"_requiredBy\": [\n    \"/tenpay\"\n  ],\n  \"_resolved\": \"https://registry.npm.taobao.org/urllib/download/urllib-2.34.2.tgz\",\n  \"_shasum\": \"ce8ddafdeb22a40265094c1aa961bcbe7c8662b8\",\n  \"_spec\": \"urllib@^2.33.0\",\n  \"_where\": \"C:\\\\Users\\\\ma250\\\\Desktop\\\\云开发直播\\\\02-代码\\\\HMYG\\\\cloudfunction\\\\pay\\\\node_modules\\\\tenpay\",\n  \"author\": {\n    \"name\": \"fengmk2\",\n    \"email\": \"fengmk2@gmail.com\",\n    \"url\": \"https://fengmk2.com\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/node-modules/urllib/issues\"\n  },\n  \"bundleDependencies\": false,\n  \"dependencies\": {\n    \"any-promise\": \"^1.3.0\",\n    \"content-type\": \"^1.0.2\",\n    \"debug\": \"^2.6.9\",\n    \"default-user-agent\": \"^1.0.0\",\n    \"digest-header\": \"^0.0.1\",\n    \"ee-first\": \"~1.1.1\",\n    \"formstream\": \"^1.1.0\",\n    \"humanize-ms\": \"^1.2.0\",\n    \"iconv-lite\": \"^0.4.15\",\n    \"ip\": \"^1.1.5\",\n    \"proxy-agent\": \"^3.1.0\",\n    \"pump\": \"^3.0.0\",\n    \"qs\": \"^6.4.0\",\n    \"statuses\": \"^1.3.1\",\n    \"utility\": \"^1.16.1\"\n  },\n  \"deprecated\": false,\n  \"description\": \"Help in opening URLs (mostly HTTP) in a complex world — basic and digest authentication, redirections, cookies and more.\",\n  \"devDependencies\": {\n    \"@types/mocha\": \"^5.2.5\",\n    \"@types/node\": \"^10.12.18\",\n    \"agentkeepalive\": \"^4.0.0\",\n    \"autod\": \"*\",\n    \"benchmark\": \"^2.1.4\",\n    \"bluebird\": \"*\",\n    \"busboy\": \"^0.2.14\",\n    \"co\": \"*\",\n    \"coffee\": \"1\",\n    \"git-contributor\": \"^1.0.10\",\n    \"http-proxy\": \"^1.16.2\",\n    \"intelli-espower-loader\": \"^1.0.1\",\n    \"istanbul\": \"*\",\n    \"jshint\": \"*\",\n    \"mkdirp\": \"^0.5.1\",\n    \"mocha\": \"3\",\n    \"muk\": \"^0.5.3\",\n    \"pedding\": \"^1.1.0\",\n    \"power-assert\": \"^1.4.2\",\n    \"semver\": \"5\",\n    \"tar\": \"^4.4.8\",\n    \"through2\": \"^2.0.3\",\n    \"typescript\": \"^3.2.2\"\n  },\n  \"engines\": {\n    \"node\": \">= 0.10.0\"\n  },\n  \"files\": [\n    \"lib\"\n  ],\n  \"homepage\": \"https://github.com/node-modules/urllib\",\n  \"keywords\": [\n    \"urllib\",\n    \"http\",\n    \"urlopen\",\n    \"curl\",\n    \"wget\",\n    \"request\",\n    \"https\"\n  ],\n  \"license\": \"MIT\",\n  \"main\": \"lib/index.js\",\n  \"name\": \"urllib\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/node-modules/urllib.git\"\n  },\n  \"scripts\": {\n    \"autod\": \"autod -w --prefix '^' -t test -e examples\",\n    \"ci\": \"npm run lint && npm run test-cov\",\n    \"contributor\": \"git-contributor\",\n    \"lint\": \"jshint .\",\n    \"test\": \"npm run lint && npm run test-local\",\n    \"test-cov\": \"istanbul cover node_modules/mocha/bin/_mocha -- -t 30000 -r intelli-espower-loader test/*.test.js\",\n    \"test-local\": \"mocha -t 30000 -r intelli-espower-loader test/*.test.js\"\n  },\n  \"types\": \"lib/index.d.ts\",\n  \"version\": \"2.34.2\"\n}\n","\n\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar utility = require('utility');\nvar urllib = require('./urllib');\n\nmodule.exports = HttpClient;\n\nfunction HttpClient(options) {\n  EventEmitter.call(this);\n  options = options || {};\n\n  if (options.agent !== undefined) {\n    this.agent = options.agent;\n    this.hasCustomAgent = true;\n  } else {\n    this.agent = urllib.agent;\n    this.hasCustomAgent = false;\n  }\n\n  if (options.httpsAgent !== undefined) {\n    this.httpsAgent = options.httpsAgent;\n    this.hasCustomHttpsAgent = true;\n  } else {\n    this.httpsAgent = urllib.httpsAgent;\n    this.hasCustomHttpsAgent = false;\n  }\n  this.defaultArgs = options.defaultArgs;\n}\nutil.inherits(HttpClient, EventEmitter);\n\nHttpClient.prototype.request = HttpClient.prototype.curl = function (url, args, callback) {\n  if (typeof args === 'function') {\n    callback = args;\n    args = null;\n  }\n  args = args || {};\n  if (this.defaultArgs) {\n    args = utility.assign({}, [ this.defaultArgs, args ]);\n  }\n  args.emitter = this;\n  args.agent = getAgent(args.agent, this.agent);\n  args.httpsAgent = getAgent(args.httpsAgent, this.httpsAgent);\n  return urllib.request(url, args, callback);\n};\n\nHttpClient.prototype.requestThunk = function (url, args) {\n  args = args || {};\n  if (this.defaultArgs) {\n    args = utility.assign({}, [ this.defaultArgs, args ]);\n  }\n  args.emitter = this;\n  args.agent = getAgent(args.agent, this.agent);\n  args.httpsAgent = getAgent(args.httpsAgent, this.httpsAgent);\n  return urllib.requestThunk(url, args);\n};\n\nfunction getAgent(agent, defaultAgent) {\n  return agent === undefined ? defaultAgent : agent;\n}\n","\n\nvar util = require('util');\nvar debug = require('debug')('urllib');\nvar ms = require('humanize-ms');\nvar HttpClient = require('./httpclient');\n\nvar _Promise;\n\nmodule.exports = HttpClient2;\n\nfunction HttpClient2(options) {\n  HttpClient.call(this, options);\n}\n\nutil.inherits(HttpClient2, HttpClient);\n\nHttpClient2.prototype.request = HttpClient2.prototype.curl = function request(url, args) {\n  var self = this;\n  args = args || {};\n  args.retry = args.retry || 0;\n  if (args.retryDelay) {\n    args.retryDelay = ms(args.retryDelay);\n  }\n  args.isRetry = args.isRetry || function(res) {\n    return res.status >= 500;\n  };\n  return HttpClient.prototype.request.call(self, url, args)\n  .then(function(res) {\n    if (args.retry > 0 && typeof args.isRetry === 'function' && args.isRetry(res)) {\n      args.retry--;\n      debug('retry request %s, remain %s', url, args.retry);\n      if (args.retryDelay) {\n        debug('retry after %sms', args.retryDelay);\n        return sleep(args.retryDelay).then(function() { return self.request(url, args); });\n      }\n      return self.request(url, args);\n    }\n    return res;\n  })\n  .catch(function(err) {\n    if (args.retry > 0) {\n      args.retry--;\n      debug('retry request %s, remain %s, err %s', url, args.retry, err);\n      if (args.retryDelay) {\n        debug('retry after %sms', args.retryDelay);\n        return sleep(args.retryDelay).then(function() { return self.request(url, args); });\n      }\n      return self.request(url, args);\n    }\n    throw err;\n  });\n};\n\nHttpClient2.prototype.requestThunk = function requestThunk(url, args) {\n  var self = this;\n  return function(callback) {\n    self.request(url, args)\n    .then(function(res) {\n      var cb = callback;\n      // make sure cb(null, res) throw error won't emit catch callback below\n      callback = null;\n      cb(null, res);\n    })\n    .catch(function(err) {\n      if (!callback) {\n        // TODO: how to handle this error?\n        return;\n      }\n      callback(err);\n    });\n  };\n};\n\nfunction sleep(ms) {\n  if (!_Promise) {\n    _Promise = require('any-promise');\n  }\n\n  return new _Promise(function(resolve) {\n    setTimeout(resolve, ms);\n  });\n}\n"]}